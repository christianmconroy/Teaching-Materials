---
title: "Graph Code"
author: "Ben Ortiz"
date: "6/30/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load igraph

```{r}
library(igraph)
```

## Load Data/Edge list

```{r}
el <- read.csv('southpark.csv', stringsAsFactors = F)

head(el)
```

## Create Edgelist and Nodelist

```{r}
nl <- rbind(
  data.frame(
    name = unique(el$episode), 
    type = 'Episode', 
    stringsAsFactors = F
  ),
  data.frame(
    name = unique(el$character),
    type = 'Character',
    stringsAsFactors = F
  )
)

head(nl)

```

## Create Graph

```{r}
g <- graph_from_data_frame(el, F, nl)

g
```



## Filter Nodes and Edges

```{r}
E(g)["Stan" %--% V(g)]
```

```{r}
V(g)[degree(g) > 100]
```

```{r}
head(degree(g))
```


## Filter graph

```{r}
subnet <- g %>%
  #remove all edges NOT connected to episode of interest
  {. - E(.)[!'Season 1 Episode 1' %--% V(.)]} %>%
  #remove all nodes that have a degree of 0
  {. - V(.)[degree(.) == 0]}

subnet

# This is useful if we want to highlight one cluster! [Can use and just convert the network object to igraph and back] Actually. Prob easier to just do directly with the ego network function below. 
```

```{r}
plot(subnet, vertex.size =0)
```

```{r}
ego(
  g,
  order = 1, #max distance from nodes
  nodes = "Season 1 Episode 1", #nodes of interest 
  mindist = 0, #min distance from nodes
)

make_ego_graph(g, nodes = "Season 1 Episode 1")

# Ego networks consist of a focal node ("ego") and the nodes to whom ego is directly connected to (these are called "alters") plus the ties, if any, among the alters.
```

## Character network

```{r}
charNet <- g %>%
  bipartite.projection(types = V(.)$type == 'Episode') %>%
  .[[1]]

charNet

# Basically does the matrix algebra for you. 
```

## Remove Supernodes and Weak Edges

```{r}
hist(degree(charNet), breaks = 100)
```


```{r}
hist(E(charNet)$weight, breaks = max(E(charNet)$weight))
```
```{r}
subnet <- charNet %>%
  #remove nodes that are essentially attached to everyone
  {. - V(.)[degree(.) > 2000]} %>% 
  #remove edges that only connect characters for 15 episodes
  {. - E(.)[weight <= 15]} %>%
  #remove all nodes with edges
  {. - V(.)[degree(.) == 0]}

subnet
```

```{r}
plot(subnet, vertex.size = 5, vertex.label = '')
```

## Keep largest Component

```{r}
not_lrg <- subnet %>%
  components() %>%
  {
    which(.$membership != which.max(.$csize))
  } 

lrg <- subnet - not_lrg

plot(lrg, vertex.size = 5, vertex.label = '')

# What we've done, but I think our way is a bit better. 
```

## Identify Communities

```{r}
com <- walktrap.community(lrg)

com

# This function tries to find densely connected subgraphs, also called communities in a graph via random walks. The idea is that short random walks tend to stay in the same community.
# This function is the implementation of the Walktrap community finding algorithm, see Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106

# Might be interesting to compare this to ADMS at some point 
```

```{r}
V(lrg)$community <- membership(com)

plot(lrg, 
     vertex.size = 5, 
     vertex.label = '', 
     vertex.color = V(lrg)$community,
     mark.groups = com)

# So we attacb their membershup here. Interestig that some fall in both networks. Those are the accounts that would matter obviously. 
```

```{r}
V(lrg)[[community == 2]]
```


## Explore Metrics

```{r}
c('page_rank', 
  'hub_score', 
  'authority_score', 
  'eigen_centrality', 
  'closeness', 
  'betweenness', 
  'degree') %>%
  setNames(.,.) %>%
  lapply( 
    function(d){
      x <- call(d, lrg) %>%
        eval 
      
      if('vector' %in% names(x)){
        x <- x$vector
      }
      
      if(d != 'closeness'){
        x <- round(x, 3)
      } else {
        x <- round(x, 6)
      }
      x %>% sort(T) %>% head(8) 
  })
```